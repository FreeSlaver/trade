---
layout: page

title: Redis线上问题
category: redis
categoryStr: redis
tags: [redis,线上问题]
keywords:
description:
---
Redis线上问题：
问题：
* 业务逻辑复杂，频繁访问redis，接口响应时间有提升空间
* 线上要清空一个db的数据，执行flushdb后，数据依然存在（原因：该db内数据量大，清空操作超过3秒，sentinel发现3秒内，master无正确响应，就将slave拉起作为master，从进行同步，陷入循环。。。）
* Redis目前的主从同步机制，主从连接断开后，如果从落后的数据超过1M（可配置，越大内存开销越大），则需要重新全量同步一次，一次全量同步会产生极大的内存、磁盘、CPU及网络开销。主从全量同步过程中，如果写入比较多，主从同步缓冲区就会不断累积写入的数据，当累积的数据超出限制时，主从连接就会断开，此时从又必须重新向主请求全量同步，如此往复... 导致同步一直不能成功
* 数据量很大时，redis的bgsave操作，虽然是子进程操作，但是也会阻塞redis，导致超时
　　 方案：
* mysql读写分离，并分库，分表
* redis数据分片，把重要、不重要的数据分开到两个redis实例分别存放
* 代码中减少redis网络IO请求，多用mget、hmget、pipeline等一次性读多条数据命令
* 代码中考虑用更合适的redis数据结构以及时间复杂度少的命令。 Instagram公司优化Redis使用内存案例
* 设计数据结构时，尽量减小单个key的value大小，如果单例redis中数据量过大，故障恢复或者同步过程会很慢。单例redis最大使用内存一定要小于机器最大内存的一半。
* 清空一个数据量很大的db前，先调大sentinel的自动故障转移时间，清空后再设置回来。
* 适当扩大client-output-buffer-limit slave 256mb 64mb 60 的配置值
* 一定要设置限流，运维层限制一道，代码层限制一道，保证整体服务器不宕机。
　　备选方案：
* 复杂的redis操作，可以考虑用短小的lua脚本执行，用eval和evalsha命令执行（优点：充分利用CPU，减少网络IO时间。缺点：不方便维护，要保证脚本不阻塞）
* 传统的一主多从A--B&C 当把B拉起为master时，C仍然会清空自身数据来同步B，psync的断点续传对此无作用，所以考虑改为变为A--B--C同步结构
* redis集群（时间紧，考虑但是暂时不会采用）
* 采用主不开持久化，从开持久化，不会出现数据量大，bgsave导致的连接超时情况（缺点：A--B&C模式下，A故障并自动拉起或者由sentinel把B被拉起为master，中间的心跳检测过程中，还是会有一个间隔，导致从同步主，发现A没有数据，会清空自身的数据，很危险！）

Redis 服务上线当天，就密切关注 Redis 的一些重要监控指标（clients：客户端连接数、memory、stats：服务器每秒钟执行的命令数量、commandstats：一些关键命令的执行统计信息、redis.error.log：异常日志）。（参考自《Redis监控方案》）

